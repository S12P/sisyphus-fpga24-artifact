#include <ap_int.h>
#include <hls_stream.h>
#include <hls_vector.h>
#include <cstring>
#include <algorithm> // For std::max
#include <iostream>

typedef hls::vector<float,16> float16;
typedef hls::vector<float,8> float8;
typedef hls::vector<float,4> float4;
typedef hls::vector<float,2> float2;

/*************************************************
 This file was automatically generated by Prometheus
*************************************************/

void load_A_S1(float2 A[18900], float A_S1[180][210], float alpha){
#pragma HLS inline off

    LOAD_A_S1: for (int i = 0; i < 180; i++) {
        for (int k = 0; k < 210; k+=2) {
            #pragma HLS pipeline
            float2 A_tmp = A[i*210/2+k/2] * alpha;
            A_S1[i][k] = A_tmp[0];
            A_S1[i][k+1] = A_tmp[1];
        }
    }
}

void load_B_S1(float2 B[19950], float B_S1[210][190]){
#pragma HLS inline off

        LOAD_B_S1: for (int k = 0; k < 210; k++) {
            for (int j = 0; j < 190; j+=2) {
                #pragma HLS pipeline

                float2 B_tmp = B[k*190/2+j/2];
                B_S1[k][j] = B_tmp[0];
                B_S1[k][j+1] = B_tmp[1];
            }
        }
}

void load_C_S3(float4 C[10450], float C_S3[190][220]){
    #pragma HLS inline off



    LOAD_C_S3: for (int k = 0; k < 190; k++) {
        for (int j = 0; j < 220; j+=4) {
            #pragma HLS pipeline
            float4 C_tmp = C[k*220/4+j/4];
            C_S3[k][j] = C_tmp[0];
            C_S3[k][j+1] = C_tmp[1];
            C_S3[k][j+2] = C_tmp[2];
            C_S3[k][j+3] = C_tmp[3];
        }
    }
}

void load_D_S2(float4 D[9900], float D_S2[9][4], float beta, int t, int shift, int i0, int j0){
#pragma HLS inline off
    int i;
    int j;
    if (!(t >= shift && i0 < 20 && j0 < 55)){
        return;
    }
    LOAD_D_S2: for (int i1 = 0; i1 < 9; i1++) {
        for (int j1 = 0; j1 < 4; j1+=4) {
            #pragma HLS pipeline
            i = i0 * 9 + i1;
            j = j0 * 4 + j1;
            float4 D_tmp = D[i*220/4+j/4] * beta;
            D_S2[i1][j1] = D_tmp[0];
            D_S2[i1][j1+1] = D_tmp[1];
            D_S2[i1][j1+2] = D_tmp[2];
            D_S2[i1][j1+3] = D_tmp[3];
        }
    }
}

void store_send_tmp_S1_S2(float2 tmp[17100], float tmp_S0_S1[9][10], hls::stream<float2>& toTask3, int i0, int j0){
    #pragma HLS inline off
    if(i0 == 0 && j0 == -1){
        return;
    }

    int i;
    int j;

    STORE_TMP_S1_S2: for (int i1 = 0; i1 < 9; i1++) {
        for (int j1 = 0; j1 < 10; j1+=2) {
            #pragma HLS pipeline
            i = i0 * 9 + i1;
            j = j0 * 10 + j1;
            float2 tmp_tmp;
            tmp_tmp[0] = tmp_S0_S1[i1][j1];
            tmp_tmp[1] = tmp_S0_S1[i1][j1+1];

            tmp[i*190/2+j/2] = tmp_tmp;
            toTask3.write(tmp_tmp);

            tmp_S0_S1[i1][j1] = 0.0;
            tmp_S0_S1[i1][j1+1] = 0.0;
        }
    }
}

void read_task3(float tmp_S3[180][190], hls::stream<float2>& toTask3, int i0, int j0){
#pragma HLS inline off

    if (!(i0 < 20 && j0 < 19)){
        return;
    }
    int i;
    int j;
    READ_TASK3: for (int i1 = 0; i1 < 9; i1++) {
        for (int j1 = 0; j1 < 10; j1+=2) {
            #pragma HLS pipeline

            i = i0 * 9 + i1;
            j = j0 * 10 + j1;

            float2 tmp = toTask3.read();
            tmp_S3[i][j] = tmp[0];
            tmp_S3[i][j+1] = tmp[1];
        }
    }
}

void store_D_S3(float4 D[9900], float D_S2_S3[9][4], int i0, int j0){
#pragma HLS inline off
    if(i0 == 0 && j0 == -1){
        return;
    }
    int i;
    int j;
    STORE_D_S3: for (int i1 = 0; i1 < 9; i1++) {
        for (int j1 = 0; j1 < 4; j1+=4) {
            #pragma HLS pipeline
            i = i0 * 9 + i1;
            j = j0 * 4 + j1;
            float4 D_tmp;
            D_tmp[0] = D_S2_S3[i1][j1];
            D_tmp[1] = D_S2_S3[i1][j1+1];
            D_tmp[2] = D_S2_S3[i1][j1+2];
            D_tmp[3] = D_S2_S3[i1][j1+3];
            D[i*220/4+j/4] = D_tmp;
        }
    }
}

void task1(float tmp_S0_S1[9][10],float A_S1[180][210],float B_S1[210][190],int i0_S1_S2,int j0_S1_S2){
    #pragma HLS inline off

    int i,j,k;
    TASK_1: for (int k0 = 0; k0 < 35; k0++) { // 1260
        #pragma HLS pipeline II=2
        for (int i1 = 0; i1 < 9; i1++) {
            #pragma HLS unroll
            for (int j1 = 0; j1 < 10; j1++) {
                #pragma HLS unroll
                for (int k1 = 0; k1 < 6; k1++) {
                    #pragma HLS unroll
                    i = i0_S1_S2 * 9 + i1;
                    j = j0_S1_S2 * 10 + j1;
                    k = k0 * 6 + k1;
                    tmp_S0_S1[i1][j1] += A_S1[i][k] * B_S1[k][j];
                }
            }
        }
    }
}

void task3(float D_S2_S3[9][4],float tmp_S3[180][190],float C_S3[190][220],int i0_S2_S3,int j0_S2_S3){
    #pragma HLS inline off
    int i,j,k;
    TASK_3: for (int k0 = 0; k0 < 19; k0++) { // 3348
		#pragma HLS pipeline II=2
        for (int j1 = 0; j1 < 4; j1++) {
            #pragma HLS unroll
            for (int i1 = 0; i1 < 9; i1++) {
                #pragma HLS unroll
                for (int k1 = 0; k1 < 10; k1++) {
                    #pragma HLS unroll
                    j = j0_S2_S3 * 4 + j1;
                    i = i0_S2_S3 * 9 + i1;
                    k = k0 * 10 + k1;
                    D_S2_S3[i1][j1] += tmp_S3[i][k] * C_S3[k][j];
                }
            }
        }
    }
}

void step0(float alpha, float2 tmp[17100], float2 A[18900], float2 B[19950], hls::stream<float2>& toTask3) {
#pragma HLS inline off

    float tmp_S0_S1[2][9][10];
    #pragma HLS array_partition variable=tmp_S0_S1 complete
    float A_S1[180][210];
    #pragma HLS array_partition variable=A_S1 cyclic factor=9 dim=1
    #pragma HLS array_partition variable=A_S1 cyclic factor=3 dim=2
    float B_S1[210][190];
    #pragma HLS array_partition variable=B_S1 cyclic factor=3 dim=1
    #pragma HLS array_partition variable=B_S1 cyclic factor=10 dim=2
    //#pragma HLS bind_storage variable=B_S1 type=RAM_S2P impl=URAM


    load_A_S1(A, A_S1, alpha); // 104
    load_B_S1(B, B_S1); // 107
    ZERO: for(int i1 = 0; i1 < 9; i1++){
        for(int j1 = 0; j1 < 10; j1++){
            tmp_S0_S1[0][i1][j1] = 0.0;
            tmp_S0_S1[1][i1][j1] = 0.0;
        }
    }

    STEP_0_1: for (int t = 0; t < 20*19; t++) {
        int i0_S1_S2 = t / 19;
        int j0_S1_S2 = t % 19;
        int i0_S1_S2_lag = (t-1) / 19;
        int j0_S1_S2_lag = (t-1) % 19;
        #pragma HLS dataflow
        
        task1(tmp_S0_S1[t%2],A_S1,B_S1,i0_S1_S2,j0_S1_S2);
        store_send_tmp_S1_S2(tmp, tmp_S0_S1[(t+1)%2], toTask3, i0_S1_S2_lag, j0_S1_S2_lag); 
    }
    store_send_tmp_S1_S2(tmp, tmp_S0_S1[1], toTask3, 19, 18); 
}

void step1_out_wrap(int t, float beta, float4 D[9900], float D_S2_S3[9][4], float tmp_S3[180][190], hls::stream<float2>& toTask3,
    int i0_S1_S2, int j0_S1_S2, int i0_S2_S3, int j0_S2_S3){
    #pragma HLS inline off 

    read_task3(tmp_S3, toTask3, i0_S1_S2, j0_S1_S2);
    load_D_S2(D, D_S2_S3, beta, t, shift, i0_S2_S3, j0_S2_S3); // 87
}

void step_1_compute_store(float D_S2_S3[2][9][4], float tmp_S3[180][190], float C_S3[190][220], float4 D[9900],int t, int i0_S2_S3, int j0_S2_S3, int i0_S2_S3_lag, int j0_S2_S3_lag){
    #pragma HLS inline off
    #pragma HLS dataflow
    
    task3(D_S2_S3[t%2],tmp_S3,C_S3,i0_S2_S3,j0_S2_S3);
    store_D_S3(D,D_S2_S3[(t+1)%2],i0_S2_S3_lag,j0_S2_S3_lag); // 85
}

void step1( float beta, float4 C[10450], float4 D[9900], hls::stream<float2>& toTask3) {
#pragma HLS inline off

    float D_S2_S3[2][9][4];
    #pragma HLS array_partition variable=D_S2_S3 complete dim=0
    float tmp_S3[180][190];
    #pragma HLS array_partition variable=tmp_S3 cyclic factor=9 dim=1
    #pragma HLS array_partition variable=tmp_S3 cyclic factor=5 dim=2
    float C_S3[190][220];
    #pragma HLS array_partition variable=C_S3 cyclic factor=5 dim=1
    #pragma HLS array_partition variable=C_S3 cyclic factor=4 dim=2
    //#pragma HLS bind_storage variable=C_S3 type=RAM_S2P impl=URAM

    load_C_S3(C, C_S3); // 95

    STEP_1_1: for (int t = 0; t < 20*55 + shift; t++) {
        #pragma HLS loop_tripcount min=1135 max=1135 avg=1135
        int i0_S1_S2 = t / 19;
        int j0_S1_S2 = t % 19;
        int i0_S2_S3 = (t-shift)/55;
        int j0_S2_S3 = (t-shift)%55;
        int i0_S2_S3_lag = (t-shift-1)/55;
        int j0_S2_S3_lag = (t-shift-1)%55;

        step1_out_wrap(t,shift,beta,D,D_S2_S3[t%2],tmp_S3,toTask3,i0_S1_S2,j0_S1_S2,i0_S2_S3,j0_S2_S3);
        if (t >= shift && i0_S2_S3 < 20 && j0_S2_S3 < 55){
            step_1_compute_store(D_S2_S3,tmp_S3,C_S3,D,t,i0_S2_S3,j0_S2_S3,i0_S2_S3_lag,j0_S2_S3_lag);
        }
    }
    store_D_S3(D,D_S2_S3[0],19,54);
}

    
extern "C"{
void kernel_nlp(float alpha, float beta, float2 tmp[17100], float2 A[18900], float2 B[19950], float4 C[10450], float4 D[9900]) {

#pragma HLS INTERFACE m_axi port=tmp offset=slave bundle=kernel_tmp
#pragma HLS INTERFACE m_axi port=A offset=slave bundle=kernel_A
#pragma HLS INTERFACE m_axi port=B offset=slave bundle=kernel_B
#pragma HLS INTERFACE m_axi port=C offset=slave bundle=kernel_C
#pragma HLS INTERFACE m_axi port=D offset=slave bundle=kernel_D

#pragma HLS INTERFACE s_axilite port=alpha bundle=control
#pragma HLS INTERFACE s_axilite port=beta bundle=control
#pragma HLS INTERFACE s_axilite port=tmp bundle=control
#pragma HLS INTERFACE s_axilite port=A bundle=control
#pragma HLS INTERFACE s_axilite port=B bundle=control
#pragma HLS INTERFACE s_axilite port=C bundle=control
#pragma HLS INTERFACE s_axilite port=D bundle=control
#pragma HLS AGGREGATE VARIABLE=tmp
#pragma HLS AGGREGATE VARIABLE=A
#pragma HLS AGGREGATE VARIABLE=B
#pragma HLS AGGREGATE VARIABLE=C
#pragma HLS AGGREGATE VARIABLE=D
#pragma HLS INTERFACE s_axilite port=return bundle=control

    hls::stream<float2> toTask3;
    #pragma HLS stream variable=toTask3 depth=1800
    #pragma HLS bind_storage variable=toTask3 type=FIFO impl=URAM

    #pragma HLS dataflow

    step0(alpha,tmp,A,B,toTask3);
    step1(beta,C,D,toTask3);
}
}

