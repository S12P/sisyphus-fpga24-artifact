debug mode
Warning: this is an empty file (no tokens found): not even a CR present! (but not an error using the token stream unparsing) 

 Total BRAM size is 3145728 byte.
==============================================
-----=# Memory Burst Optimization Start#=----
==============================================

lifting burst for coarse grained paralleld loop: 
lifting memory burst for general issues: 
access range for variable 's' within scope '{#pragma ACCEL PARALLELs[i * 2 + i_sub] =((float )0);}':  
i * 2 + i_sub..i * 2 + i_sub exact
access range for variable 's' within scope 'for(int i_sub = 0;i_sub < 2;++i_sub) {...}':  
i * 2..1 + i * 2 exact
access range for variable 's' within scope '{#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs[i * 2 + i_sub] =((float )0);}}':  
i * 2..1 + i * 2 exact
access range for variable 's' within scope 'for(i = 0;i < 195;i++) {...}':  
0..389 exact
access range for variable 's' within scope '{for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs[i * 2 + i_sub] =((float )0);}}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}}':  
0..389 exact
access range for variable 's' within scope '{#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}':  
j..j exact
access range for variable 's' within scope 'for(j = 0;j < 390;j++) {...}':  
0..389 exact
access range for variable 's' within scope '{#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}':  
0..389 exact
access range for variable 's' within scope 'for(i = 0;i < 410;i++) {...}':  
0..389 exact
access range for variable 'r' within scope '{#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}':  
i..i exact
access range for variable 'r' within scope 'for(j = 0;j < 390;j++) {...}':  
i..i exact
access range for variable 'r' within scope '{#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}':  
i..i exact
access range for variable 'r' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
access range for variable 'A' within scope '{#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}':  
i * 390L + j..i * 390L + j exact
access range for variable 'A' within scope 'for(j = 0;j < 390;j++) {...}':  
i * 390L..389L + i * 390L exact
access range for variable 'A' within scope '{#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}':  
i * 390L..389L + i * 390L exact
access range for variable 'A' within scope 'for(i = 0;i < 410;i++) {...}':  
0..159899 exact
access range for variable 'q' within scope '{#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}':  
i..i exact
access range for variable 'q' within scope 'for(j = 0;j < 390;j++) {...}':  
i..i exact
access range for variable 'q' within scope '{#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}':  
i..i exact
access range for variable 'q' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
access range for variable 'p' within scope '{#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}':  
j..j exact
access range for variable 'p' within scope 'for(j = 0;j < 390;j++) {...}':  
0..389 exact
access range for variable 'p' within scope '{#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}':  
0..389 exact
access range for variable 'p' within scope 'for(i = 0;i < 410;i++) {...}':  
0..389 exact
access range for variable 's' within scope '{for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs[i * 2 + i_sub] =((float )0);}}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}}':  
0..389 exact
access range for variable 's' within scope '{for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs[i * 2 + i_sub] =((float )0);}}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels[j] = s[j] + r[i] * A[i * 390L + j];q[i] = q[i] + A[i * 390L + j] * p[j];}}}':  
0..389 exact
Memory burst inferred: variable 's' for GENERAL (__merlinkernel_kernel_bicg.c)
  burst buffer size = 1560 bytes
access range for variable 's' within scope 'for(i = 0;i < 410;i++) {...}':  
na..na inexact
Cannot infer burst for variable 's' in scope 'SgForStatement:for(i = 0;i < 410;i++) {...}' because of infinite bound
access range for variable 'r' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
access range for variable 'r' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
access range for variable 'A' within scope 'for(i = 0;i < 410;i++) {...}':  
0..159899 exact
access range for variable 'A' within scope 'for(i = 0;i < 410;i++) {...}':  
0..159899 exact
access range for variable 'q' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
access range for variable 'q' within scope 'for(i = 0;i < 410;i++) {...}':  
0..409 exact
Memory burst inferred: variable 'q' for GENERAL (__merlinkernel_kernel_bicg.c)
  burst buffer size = 1640 bytes
access range for variable 'p' within scope 'for(i = 0;i < 410;i++) {...}':  
0..389 exact
access range for variable 'p' within scope 'for(i = 0;i < 410;i++) {...}':  
0..389 exact
parent pipeline found
[MARS-BURST-MSG] Read to array/pointer 'r' .
[MARS-BURST-PARSING] Burst inference granularity of array 'r' is depends on loop iterator 0
[MARS-BURST-PARSING] Burst inference buffer size of array 'r' is 410
{#pragma ACCEL interface variable=r depth=410 max_depth=410#pragma ACCEL interface variable=p depth=390 max_depth=390#pragma ACCEL interface variable=q depth=410 max_depth=410#pragma ACCEL interface variable=s depth=390 max_depth=390#pragma ACCEL interface variable=A depth=410,390 max_depth=410,390__merlin_access_range(r,0,409UL);__merlin_access_range(p,0,389UL);__merlin_access_range(q,0,409UL);__merlin_access_range(s,0,389UL);__merlin_access_range(A,0,159899);int i;int j;{float r_5_0_buf[410];float q_buf[410];float s_buf[390];memcpy((void *)(&s_buf[0]),(const void *)(&s[0]),sizeof(float ) * 390);for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs_buf[i * 2 + i_sub] =((float )0);}}memcpy((void *)(&q_buf[0]),(const void *)(&q[0]),sizeof(float ) * 410);{memcpy((void *)(&r_5_0_buf[0]),(const void *)(&r[0]),sizeof(float ) * 410);}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq_buf[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels_buf[j] = s_buf[j] + r_5_0_buf[i] * A[i * 390L + j];q_buf[i] = q_buf[i] + A[i * 390L + j] * p[j];}}memcpy((void *)(&q[0]),(const void *)(&q_buf[0]),sizeof(float ) * 410);memcpy((void *)(&s[0]),(const void *)(&s_buf[0]),sizeof(float ) * 390);}}
[MARS-BURST-MSG] Read to array/pointer 'A' .
[MARS-BURST-PARSING] Burst inference granularity of array 'A' is depends on loop iterator 0
[MARS-BURST-PARSING] Burst inference buffer size of array 'A' is 159900
{#pragma ACCEL interface variable=r depth=410 max_depth=410#pragma ACCEL interface variable=p depth=390 max_depth=390#pragma ACCEL interface variable=q depth=410 max_depth=410#pragma ACCEL interface variable=s depth=390 max_depth=390#pragma ACCEL interface variable=A depth=410,390 max_depth=410,390__merlin_access_range(r,0,409UL);__merlin_access_range(p,0,389UL);__merlin_access_range(q,0,409UL);__merlin_access_range(s,0,389UL);__merlin_access_range(A,0,159899);int i;int j;{float A_5_0_buf[159900];float r_5_0_buf[410];float q_buf[410];float s_buf[390];memcpy((void *)(&s_buf[0]),(const void *)(&s[0]),sizeof(float ) * 390);for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs_buf[i * 2 + i_sub] =((float )0);}}memcpy((void *)(&q_buf[0]),(const void *)(&q[0]),sizeof(float ) * 410);{memcpy((void *)(&r_5_0_buf[0]),(const void *)(&r[0]),sizeof(float ) * 410);}{memcpy((void *)(&A_5_0_buf[0]),(const void *)(&A[0]),sizeof(float ) * 159900L);}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq_buf[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels_buf[j] = s_buf[j] + r_5_0_buf[i] * A[i * 390L + j];q_buf[i] = q_buf[i] + A_5_0_buf[i * 390L + j] * p[j];}}memcpy((void *)(&q[0]),(const void *)(&q_buf[0]),sizeof(float ) * 410);memcpy((void *)(&s[0]),(const void *)(&s_buf[0]),sizeof(float ) * 390);}}
[MARS-BURST-MSG] Read to array/pointer 'A' .
[MARS-BURST-PARSING] Burst inference granularity of array 'A' is depends on loop iterator 0
[MARS-BURST-PARSING] Burst inference buffer size of array 'A' is 159900
{#pragma ACCEL interface variable=r depth=410 max_depth=410#pragma ACCEL interface variable=p depth=390 max_depth=390#pragma ACCEL interface variable=q depth=410 max_depth=410#pragma ACCEL interface variable=s depth=390 max_depth=390#pragma ACCEL interface variable=A depth=410,390 max_depth=410,390__merlin_access_range(r,0,409UL);__merlin_access_range(p,0,389UL);__merlin_access_range(q,0,409UL);__merlin_access_range(s,0,389UL);__merlin_access_range(A,0,159899);int i;int j;{float A_5_1_buf[159900];float A_5_0_buf[159900];float r_5_0_buf[410];float q_buf[410];float s_buf[390];memcpy((void *)(&s_buf[0]),(const void *)(&s[0]),sizeof(float ) * 390);for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs_buf[i * 2 + i_sub] =((float )0);}}memcpy((void *)(&q_buf[0]),(const void *)(&q[0]),sizeof(float ) * 410);{memcpy((void *)(&r_5_0_buf[0]),(const void *)(&r[0]),sizeof(float ) * 410);}{memcpy((void *)(&A_5_0_buf[0]),(const void *)(&A[0]),sizeof(float ) * 159900L);memcpy((void *)(&A_5_1_buf[0]),(const void *)(&A[0]),sizeof(float ) * 159900L);}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq_buf[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels_buf[j] = s_buf[j] + r_5_0_buf[i] * A_5_1_buf[i * 390L + j];q_buf[i] = q_buf[i] + A_5_0_buf[i * 390L + j] * p[j];}}memcpy((void *)(&q[0]),(const void *)(&q_buf[0]),sizeof(float ) * 410);memcpy((void *)(&s[0]),(const void *)(&s_buf[0]),sizeof(float ) * 390);}}
[MARS-BURST-MSG] Read to array/pointer 'p' .
[MARS-BURST-PARSING] Burst inference granularity of array 'p' is depends on loop iterator 0
[MARS-BURST-PARSING] Burst inference buffer size of array 'p' is 390
{#pragma ACCEL interface variable=r depth=410 max_depth=410#pragma ACCEL interface variable=p depth=390 max_depth=390#pragma ACCEL interface variable=q depth=410 max_depth=410#pragma ACCEL interface variable=s depth=390 max_depth=390#pragma ACCEL interface variable=A depth=410,390 max_depth=410,390__merlin_access_range(r,0,409UL);__merlin_access_range(p,0,389UL);__merlin_access_range(q,0,409UL);__merlin_access_range(s,0,389UL);__merlin_access_range(A,0,159899);int i;int j;{float p_5_0_buf[390];float A_5_1_buf[159900];float A_5_0_buf[159900];float r_5_0_buf[410];float q_buf[410];float s_buf[390];memcpy((void *)(&s_buf[0]),(const void *)(&s[0]),sizeof(float ) * 390);for(i = 0;i < 195;i++) {#pragma ACCEL PIPELINE AUTOfor(int i_sub = 0;i_sub < 2;++i_sub) {#pragma ACCEL PARALLELs_buf[i * 2 + i_sub] =((float )0);}}memcpy((void *)(&q_buf[0]),(const void *)(&q[0]),sizeof(float ) * 410);{memcpy((void *)(&r_5_0_buf[0]),(const void *)(&r[0]),sizeof(float ) * 410);}{memcpy((void *)(&A_5_0_buf[0]),(const void *)(&A[0]),sizeof(float ) * 159900L);memcpy((void *)(&A_5_1_buf[0]),(const void *)(&A[0]),sizeof(float ) * 159900L);}{memcpy((void *)(&p_5_0_buf[0]),(const void *)(&p[0]),sizeof(float ) * 390);}for(i = 0;i < 410;i++) {#pragma ACCEL PARALLEL FACTOR=1#pragma ACCEL PIPELINEq_buf[i] =((float )0.0);for(j = 0;j < 390;j++) {#pragma ACCEL parallels_buf[j] = s_buf[j] + r_5_0_buf[i] * A_5_1_buf[i * 390L + j];q_buf[i] = q_buf[i] + A_5_0_buf[i * 390L + j] * p_5_0_buf[j];}}memcpy((void *)(&q[0]),(const void *)(&q_buf[0]),sizeof(float ) * 410);memcpy((void *)(&s[0]),(const void *)(&s_buf[0]),sizeof(float ) * 390);}}
parent pipeline found
parent pipeline found
parent pipeline found
parent pipeline found
parent pipeline found
[MARS-BURST-MSG] Current analysis will skip function body or any function call in the loop.
============================================
-----=# Memory Burst Optimization End#=----
============================================

mars_opt __dummy__.c __merlinwrapper_kernel_bicg.c __merlinkernel_kernel_bicg.c  -e c -p memory_burst -a cstd=c99 -a cxxstd=c++11  -a impl_tool=sdaccel -a tool_version=vitis -a effort=standard -a generate_l2_api=on -a bus_length_threshold= -a debug_mode=debug   -I /opt/merlin/sources/merlin-compiler/trunk/source-opt/include/apint_include -I/home/spouget/iccad_24/autodse_without_tree_reduction/bicg_MEDIUM/_done/work_dir/output/fast/0 -I/home/spouget/iccad_24/autodse_without_tree_reduction/bicg_MEDIUM/_done/work_dir/output/fast/0/bicg_MEDIUM/ -I/opt/merlin/sources/merlin-compiler/trunk//mars-gen/lib/merlin -I /opt/merlin/sources/merlin-compiler/trunk/mars-gen/lib/merlin -a cflags=" -D__SYNTHESIS__  -D_MARS_COMPILER_FLOW_ "
